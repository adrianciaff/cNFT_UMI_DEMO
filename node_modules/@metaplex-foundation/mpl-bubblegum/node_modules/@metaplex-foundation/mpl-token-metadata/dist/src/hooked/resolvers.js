"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveBurnMasterEdition = exports.resolveTokenProgramForNonProgrammables = exports.resolveAuthorizationRulesProgram = exports.resolveDestinationTokenRecord = exports.resolveTokenRecord = exports.resolveOptionalTokenOwner = exports.resolveCreateV1Bytes = exports.resolveCreators = exports.resolvePrintSupply = exports.resolveDecimals = exports.resolveMasterEditionForProgrammables = exports.resolveMasterEdition = exports.resolveCollectionDetails = void 0;
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const umi_1 = require("@metaplex-foundation/umi");
const digitalAsset_1 = require("../digitalAsset");
const generated_1 = require("../generated");
const resolveCollectionDetails = (context, accounts, args, programId, isWritable) => args.isCollection ? (0, umi_1.some)((0, generated_1.collectionDetails)('V1', { size: 0 })) : (0, umi_1.none)();
exports.resolveCollectionDetails = resolveCollectionDetails;
const resolveMasterEdition = (context, accounts, args, programId, isWritable) => (0, digitalAsset_1.isNonFungible)(args.tokenStandard)
    ? [
        (0, generated_1.findMasterEditionPda)(context, { mint: (0, umi_1.publicKey)(accounts.mint[0]) }),
        isWritable,
    ]
    : [programId, false];
exports.resolveMasterEdition = resolveMasterEdition;
const resolveMasterEditionForProgrammables = (context, accounts, args, programId, isWritable) => (0, digitalAsset_1.isNonFungible)(args.tokenStandard) && (0, digitalAsset_1.isProgrammable)(args.tokenStandard)
    ? [
        (0, generated_1.findMasterEditionPda)(context, { mint: (0, umi_1.publicKey)(accounts.mint[0]) }),
        isWritable,
    ]
    : [programId, false];
exports.resolveMasterEditionForProgrammables = resolveMasterEditionForProgrammables;
const resolveDecimals = (context, accounts, args, programId, isWritable) => ((0, digitalAsset_1.isNonFungible)(args.tokenStandard) ? (0, umi_1.none)() : (0, umi_1.some)(0));
exports.resolveDecimals = resolveDecimals;
const resolvePrintSupply = (context, accounts, args, programId, isWritable) => (0, digitalAsset_1.isNonFungible)(args.tokenStandard) ? (0, umi_1.some)((0, generated_1.printSupply)('Zero')) : (0, umi_1.none)();
exports.resolvePrintSupply = resolvePrintSupply;
const resolveCreators = (context, accounts, args, programId, isWritable) => (0, umi_1.some)([
    {
        address: (0, umi_1.publicKey)(accounts.authority[0], false),
        share: 100,
        verified: true,
    },
]);
exports.resolveCreators = resolveCreators;
const resolveCreateV1Bytes = (context, accounts, args, programId, isWritable) => {
    const base = (0, mpl_toolbox_1.getMintSize)() + (0, generated_1.getMetadataSize)() + 2 * umi_1.ACCOUNT_HEADER_SIZE;
    if ((0, digitalAsset_1.isNonFungible)(args.tokenStandard)) {
        return base + (0, generated_1.getMasterEditionSize)() + umi_1.ACCOUNT_HEADER_SIZE;
    }
    return base;
};
exports.resolveCreateV1Bytes = resolveCreateV1Bytes;
const resolveOptionalTokenOwner = (context, accounts, args, programId, isWritable) => accounts.token
    ? [programId, false]
    : [context.identity.publicKey, isWritable];
exports.resolveOptionalTokenOwner = resolveOptionalTokenOwner;
const resolveTokenRecord = (context, accounts, args, programId, isWritable) => (0, digitalAsset_1.isProgrammable)(args.tokenStandard) && accounts.token[0]
    ? [
        (0, generated_1.findTokenRecordPda)(context, {
            mint: (0, umi_1.publicKey)(accounts.mint[0], false),
            token: (0, umi_1.publicKey)(accounts.token[0], false),
        }),
        isWritable,
    ]
    : [programId, false];
exports.resolveTokenRecord = resolveTokenRecord;
const resolveDestinationTokenRecord = (context, accounts, args, programId, isWritable) => (0, digitalAsset_1.isProgrammable)(args.tokenStandard)
    ? [
        (0, generated_1.findTokenRecordPda)(context, {
            mint: (0, umi_1.publicKey)(accounts.mint[0], false),
            token: (0, umi_1.publicKey)(accounts.destinationToken[0], false),
        }),
        isWritable,
    ]
    : [programId, false];
exports.resolveDestinationTokenRecord = resolveDestinationTokenRecord;
const resolveAuthorizationRulesProgram = (context, accounts, args, programId, isWritable) => accounts.authorizationRules[0]
    ? [
        context.programs.getPublicKey('mplTokenAuthRules', 'auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg'),
        false,
    ]
    : [programId, false];
exports.resolveAuthorizationRulesProgram = resolveAuthorizationRulesProgram;
const resolveTokenProgramForNonProgrammables = (context, accounts, args, programId, isWritable) => !(0, digitalAsset_1.isProgrammable)(args.tokenStandard)
    ? [
        context.programs.getPublicKey('splToken', 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
        false,
    ]
    : [programId, false];
exports.resolveTokenProgramForNonProgrammables = resolveTokenProgramForNonProgrammables;
const resolveBurnMasterEdition = (context, accounts, args, programId, isWritable) => accounts.masterEditionMint[0] === programId
    ? [programId, false]
    : [
        (0, generated_1.findMasterEditionPda)(context, {
            mint: (0, umi_1.publicKey)(accounts.masterEditionMint[0]),
        }),
        false,
    ];
exports.resolveBurnMasterEdition = resolveBurnMasterEdition;
//# sourceMappingURL=resolvers.js.map